{"version":3,"sources":["useDynamicPagination.js"],"sourcesContent":["import * as React from 'react';\nimport { useRef } from 'react';\nimport { useTimeout } from '@fluentui/react-utilities';\n/**\n * Optional hook that will enable pagination on the virtualizer so that it 'autoscrolls' to an items exact position\n * Sizes are dynamic so we require a progressive sizing array (passed in from Dynamic virtualizer hooks)\n * On short scrolls, we will go at minimum to the next/previous item so that arrow pagination works\n * All VirtualizerDynamicPaginationProps can be grabbed from dynamic Virtualizer hooks externally and passed in\n */ export const useDynamicVirtualizerPagination = (virtualizerProps, paginationEnabled = true)=>{\n    const { axis = 'vertical', currentIndex, progressiveItemSizes, virtualizerLength } = virtualizerProps;\n    const [setScrollTimer, clearScrollTimer] = useTimeout();\n    const lastScrollPos = useRef(-1);\n    const lastIndexScrolled = useRef(-1);\n    const scrollContainer = React.useRef(null);\n    const clearListeners = ()=>{\n        if (scrollContainer.current) {\n            scrollContainer.current.removeEventListener('scroll', onScroll);\n            scrollContainer.current = null;\n            clearScrollTimer();\n        }\n    };\n    React.useEffect(()=>{\n        return ()=>{\n            clearListeners();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    /**\n   * Handle scroll stop event and paginate to the closest item\n   * If the closest item is the same as the previous scroll end\n   * we paginate to the next/previous one based on direction\n   *\n   * Users/Virtualizer-Hooks must pass in a cumulative array of sizes\n   * This prevents the need to recalculate and ensures size arrays are synced externally\n   */ const onScrollEnd = React.useCallback(()=>{\n        if (!scrollContainer.current || !paginationEnabled || !(progressiveItemSizes === null || progressiveItemSizes === void 0 ? void 0 : progressiveItemSizes.current)) {\n            // No container found\n            return;\n        }\n        const currentScrollPos = Math.round(axis === 'vertical' ? scrollContainer.current.scrollTop : scrollContainer.current.scrollLeft);\n        let closestItemPos = 0;\n        let closestItem = 0;\n        const endItem = Math.min(currentIndex + virtualizerLength, progressiveItemSizes.current.length);\n        for(let i = currentIndex; i < endItem - 1; i++){\n            if (currentScrollPos <= progressiveItemSizes.current[i + 1] && currentScrollPos >= progressiveItemSizes.current[i]) {\n                // Found our in between position\n                const distanceToPrev = Math.abs(currentScrollPos - progressiveItemSizes.current[i]);\n                const distanceToNext = Math.abs(progressiveItemSizes.current[i + 1] - currentScrollPos);\n                if (distanceToPrev < distanceToNext) {\n                    closestItem = i;\n                } else {\n                    closestItem = i + 1;\n                }\n                break;\n            }\n        }\n        let nextItem;\n        if (Math.round(closestItem - lastIndexScrolled.current) === 0) {\n            // Special case for go to next/previous with minimum amount of scroll needed\n            const nextTarget = lastScrollPos.current < currentScrollPos ? 1 : -1;\n            // This will also handle a case where we scrolled to the exact correct position (noop)\n            const isSecondaryScroll = Math.round(lastScrollPos.current - currentScrollPos) === 0;\n            const posMod = isSecondaryScroll ? 0 : nextTarget;\n            nextItem = closestItem + posMod;\n        } else {\n            // Pagination for anything else can just jump to the closest!\n            nextItem = closestItem;\n        }\n        // Safeguard nextItem\n        nextItem = Math.min(Math.max(0, nextItem), progressiveItemSizes.current.length);\n        closestItemPos = progressiveItemSizes.current[nextItem];\n        if (axis === 'vertical') {\n            scrollContainer.current.scrollTo({\n                top: closestItemPos,\n                behavior: 'smooth'\n            });\n        } else {\n            scrollContainer.current.scrollTo({\n                left: closestItemPos,\n                behavior: 'smooth'\n            });\n        }\n        lastScrollPos.current = progressiveItemSizes.current[nextItem];\n        lastIndexScrolled.current = nextItem;\n    }, [\n        paginationEnabled,\n        currentIndex,\n        scrollContainer,\n        virtualizerLength,\n        axis,\n        progressiveItemSizes\n    ]);\n    /**\n   * On scroll timer that will continuously delay callback until scrolling stops\n   */ const onScroll = React.useCallback((event)=>{\n        clearScrollTimer();\n        setScrollTimer(onScrollEnd, 100);\n    }, [\n        onScrollEnd,\n        clearScrollTimer,\n        setScrollTimer\n    ]);\n    /**\n   * Pagination ref will ensure we attach listeners to containers on change\n   * It is returned from hook and merged into the scroll container externally\n   */ const paginationRef = React.useCallback((instance)=>{\n        if (!paginationEnabled) {\n            clearListeners();\n            scrollContainer.current = null;\n            return;\n        }\n        if (scrollContainer.current !== instance) {\n            clearListeners();\n            scrollContainer.current = instance;\n            if (scrollContainer.current) {\n                scrollContainer.current.addEventListener('scroll', onScroll);\n            }\n        }\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        onScroll,\n        onScrollEnd,\n        paginationEnabled\n    ]);\n    return paginationRef;\n};\n"],"names":["useDynamicVirtualizerPagination","virtualizerProps","paginationEnabled","axis","currentIndex","progressiveItemSizes","virtualizerLength","setScrollTimer","clearScrollTimer","useTimeout","lastScrollPos","useRef","lastIndexScrolled","scrollContainer","React","clearListeners","current","removeEventListener","onScroll","useEffect","onScrollEnd","useCallback","currentScrollPos","Math","round","scrollTop","scrollLeft","closestItemPos","closestItem","endItem","min","length","i","distanceToPrev","abs","distanceToNext","nextItem","nextTarget","isSecondaryScroll","posMod","max","scrollTo","top","behavior","left","event","paginationRef","instance","addEventListener"],"mappings":"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"}