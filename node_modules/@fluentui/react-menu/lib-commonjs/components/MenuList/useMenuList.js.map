{"version":3,"sources":["useMenuList.js"],"sourcesContent":["import * as React from 'react';\nimport { useMergedRefs, useEventCallback, useControllableState, getIntrinsicElementProps, slot } from '@fluentui/react-utilities';\nimport { useArrowNavigationGroup, useFocusFinders, TabsterMoveFocusEventName } from '@fluentui/react-tabster';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { useHasParentContext } from '@fluentui/react-context-selector';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { MenuContext } from '../../contexts/menuContext';\n/**\n * Returns the props and state required to render the component\n */ export const useMenuList_unstable = (props, ref)=>{\n    const { findAllFocusable } = useFocusFinders();\n    const { targetDocument } = useFluent();\n    const menuContext = useMenuContextSelectors();\n    const hasMenuContext = useHasParentContext(MenuContext);\n    const focusAttributes = useArrowNavigationGroup({\n        circular: true\n    });\n    if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {\n        // TODO throw warnings in development safely\n        // eslint-disable-next-line no-console\n        console.warn('You are using both MenuList and Menu props, we recommend you to use Menu props when available');\n    }\n    const innerRef = React.useRef(null);\n    React.useEffect(()=>{\n        const element = innerRef.current;\n        if (hasMenuContext && targetDocument && element) {\n            const onTabsterMoveFocus = (e)=>{\n                const nextElement = e.detail.next;\n                if (nextElement && element.contains(targetDocument.activeElement) && !element.contains(nextElement)) {\n                    // Preventing Tabster from handling Tab press, useMenuPopover will handle it.\n                    e.preventDefault();\n                }\n            };\n            targetDocument.addEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);\n            return ()=>{\n                targetDocument.removeEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);\n            };\n        }\n    }, [\n        innerRef,\n        targetDocument,\n        hasMenuContext\n    ]);\n    const setFocusByFirstCharacter = React.useCallback((e, itemEl)=>{\n        // TODO use some kind of children registration to reduce dependency on DOM roles\n        const acceptedRoles = [\n            'menuitem',\n            'menuitemcheckbox',\n            'menuitemradio'\n        ];\n        if (!innerRef.current) {\n            return;\n        }\n        const menuItems = findAllFocusable(innerRef.current, (el)=>el.hasAttribute('role') && acceptedRoles.indexOf(el.getAttribute('role')) !== -1);\n        let startIndex = menuItems.indexOf(itemEl) + 1;\n        if (startIndex === menuItems.length) {\n            startIndex = 0;\n        }\n        const firstChars = menuItems.map((menuItem)=>{\n            var _menuItem_textContent;\n            return (_menuItem_textContent = menuItem.textContent) === null || _menuItem_textContent === void 0 ? void 0 : _menuItem_textContent.charAt(0).toLowerCase();\n        });\n        const char = e.key.toLowerCase();\n        const getIndexFirstChars = (start, firstChar)=>{\n            for(let i = start; i < firstChars.length; i++){\n                if (char === firstChars[i]) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        // Check remaining slots in the menu\n        let index = getIndexFirstChars(startIndex, char);\n        // If not found in remaining slots, check from beginning\n        if (index === -1) {\n            index = getIndexFirstChars(0, char);\n        }\n        // If match was found...\n        if (index > -1) {\n            menuItems[index].focus();\n        }\n    }, [\n        findAllFocusable\n    ]);\n    var _props_checkedValues;\n    const [checkedValues, setCheckedValues] = useControllableState({\n        state: (_props_checkedValues = props.checkedValues) !== null && _props_checkedValues !== void 0 ? _props_checkedValues : hasMenuContext ? menuContext.checkedValues : undefined,\n        defaultState: props.defaultCheckedValues,\n        initialState: {}\n    });\n    var _props_onCheckedValueChange;\n    const handleCheckedValueChange = (_props_onCheckedValueChange = props.onCheckedValueChange) !== null && _props_onCheckedValueChange !== void 0 ? _props_onCheckedValueChange : hasMenuContext ? menuContext.onCheckedValueChange : undefined;\n    const toggleCheckbox = useEventCallback((e, name, value, checked)=>{\n        const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];\n        const newCheckedItems = [\n            ...checkedItems\n        ];\n        if (checked) {\n            newCheckedItems.splice(newCheckedItems.indexOf(value), 1);\n        } else {\n            newCheckedItems.push(value);\n        }\n        handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n            name,\n            checkedItems: newCheckedItems\n        });\n        setCheckedValues((s)=>({\n                ...s,\n                [name]: newCheckedItems\n            }));\n    });\n    const selectRadio = useEventCallback((e, name, value)=>{\n        const newCheckedItems = [\n            value\n        ];\n        setCheckedValues((s)=>({\n                ...s,\n                [name]: newCheckedItems\n            }));\n        handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n            name,\n            checkedItems: newCheckedItems\n        });\n    });\n    return {\n        components: {\n            root: 'div'\n        },\n        root: slot.always(getIntrinsicElementProps('div', {\n            // FIXME:\n            // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`\n            // but since it would be a breaking change to fix it, we are casting ref to it's proper type\n            ref: useMergedRefs(ref, innerRef),\n            role: 'menu',\n            'aria-labelledby': menuContext.triggerId,\n            ...focusAttributes,\n            ...props\n        }), {\n            elementType: 'div'\n        }),\n        hasIcons: menuContext.hasIcons || false,\n        hasCheckmarks: menuContext.hasCheckmarks || false,\n        checkedValues,\n        hasMenuContext,\n        setFocusByFirstCharacter,\n        selectRadio,\n        toggleCheckbox\n    };\n};\n/**\n * Adds some sugar to fetching multiple context selector values\n */ const useMenuContextSelectors = ()=>{\n    const checkedValues = useMenuContext_unstable((context)=>context.checkedValues);\n    const onCheckedValueChange = useMenuContext_unstable((context)=>context.onCheckedValueChange);\n    const triggerId = useMenuContext_unstable((context)=>context.triggerId);\n    const hasIcons = useMenuContext_unstable((context)=>context.hasIcons);\n    const hasCheckmarks = useMenuContext_unstable((context)=>context.hasCheckmarks);\n    return {\n        checkedValues,\n        onCheckedValueChange,\n        triggerId,\n        hasIcons,\n        hasCheckmarks\n    };\n};\n/**\n * Helper function to detect if props and MenuContext values are both used\n */ const usingPropsAndMenuContext = (props, contextValue, hasMenuContext)=>{\n    let isUsingPropsAndContext = false;\n    for(const val in contextValue){\n        if (props[val]) {\n            isUsingPropsAndContext = true;\n        }\n    }\n    return hasMenuContext && isUsingPropsAndContext;\n};\n"],"names":["useMenuList_unstable","props","ref","findAllFocusable","useFocusFinders","targetDocument","useFluent","menuContext","useMenuContextSelectors","hasMenuContext","useHasParentContext","MenuContext","focusAttributes","useArrowNavigationGroup","circular","usingPropsAndMenuContext","console","warn","innerRef","React","useRef","useEffect","element","current","onTabsterMoveFocus","e","nextElement","detail","next","contains","activeElement","preventDefault","addEventListener","TabsterMoveFocusEventName","removeEventListener","setFocusByFirstCharacter","useCallback","itemEl","acceptedRoles","menuItems","el","hasAttribute","indexOf","getAttribute","startIndex","length","firstChars","map","menuItem","_menuItem_textContent","textContent","charAt","toLowerCase","char","key","getIndexFirstChars","start","firstChar","i","index","focus","_props_checkedValues","checkedValues","setCheckedValues","useControllableState","state","undefined","defaultState","defaultCheckedValues","initialState","_props_onCheckedValueChange","handleCheckedValueChange","onCheckedValueChange","toggleCheckbox","useEventCallback","name","value","checked","checkedItems","newCheckedItems","splice","push","s","selectRadio","components","root","slot","always","getIntrinsicElementProps","useMergedRefs","role","triggerId","elementType","hasIcons","hasCheckmarks","useMenuContext_unstable","context","contextValue","isUsingPropsAndContext","val"],"mappings":"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"}